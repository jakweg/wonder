// deno-lint-ignore-file no-explicit-any no-unused-vars
const findFiles = async (src: string, condition: (name: string) => boolean) => {
  const found: string[] = []
  for await (const dirEntry of Deno.readDir(src)) {
    if (dirEntry.isDirectory) {
      found.push(...(await findFiles(`${src}/${dirEntry.name}`, condition)))
    } else if (dirEntry.isFile) {
      if (condition(dirEntry.name)) {
        found.push(`${src}/${dirEntry.name}`)
      }
    }
  }
  return found
}

const newCompiledContent = () => ({
  _content: [] as string[],
  _import_counter: 0,
  addImport(fileName: string, propertyName: string): string {
    const name = `imported_${this._import_counter++}`
    if (propertyName) {
      this._content.unshift('import * as ', name, ' from ', JSON.stringify(fileName), ';')
    } else {
      this._content.unshift('import ', name, ' from ', JSON.stringify(fileName), ';')
    }
    return name
  },
  push(line: string) {
    this._content.push(line)
  },
  finalize(): string {
    return this._content.join('')
  },
})

const candidates = await findFiles('src', name => name.endsWith('.2bc.json'))
for (const fileName of candidates) {
  const compiledContent = newCompiledContent()

  const description = JSON.parse(await Deno.readTextFile(fileName))

  compiledContent._content.unshift(`
  /*
  * THIS FILE WAS AUTOGENERATED, DO NOT CHANGE IT
  * Any change you make here will be overwritten by a compiler
  * edit appropriate .2bc.json file instead
  */
 `)
  compiledContent.push(`export const enum `)
  compiledContent.push(description.name)
  compiledContent.push('{')

  for (const name of Object.keys(description.values)) {
    compiledContent.push(name)
    compiledContent.push(',')
  }
  if (description['add-size'] === true) compiledContent.push('SIZE,')
  compiledContent.push('};')

  for (const [getterName, getter] of Object.entries(description.getters ?? {})) {
    compiledContent.push(`export const `)
    compiledContent.push(getterName)
    compiledContent.push(' = (value: ')
    compiledContent.push(description.name)
    compiledContent.push(') => { ')
    compiledContent.push(`/* This file was autogenerated, don't change */\n`)
    compiledContent.push(' switch (value) {')
    for (const [enumName, values] of Object.entries(description.values)) {
      compiledContent.push('case ')
      compiledContent.push(description.name)
      compiledContent.push('.')
      compiledContent.push(enumName)
      compiledContent.push(': return ')
      const fieldName = (getter as any).field
      const value = (values as any)[fieldName]
      if (value === undefined) throw new Error(`Value is missing for getter ${getterName} for enum ${enumName}`)
      if (typeof value === 'string') compiledContent.push(JSON.stringify(value))
      else if (typeof value === 'number') compiledContent.push(JSON.stringify(value))
      else if (typeof value === 'boolean') compiledContent.push(JSON.stringify(value))
      else if (typeof value === 'object' && fieldName.startsWith('@')) {
        const name = compiledContent.addImport(value['from'], value['property'])
        compiledContent.push(name)
        if (value['property']) {
          compiledContent.push('.')
          compiledContent.push(value['property'])
        }
      } else throw new Error('Invalid field type')
      compiledContent.push(';')
    }

    switch ((getter as any)['if-invalid-enum'] ?? 'throw') {
      case 'throw':
        compiledContent.push('default: throw new Error();')
        break
      case 'return-null':
        compiledContent.push('default: return null;')
        break
      case 'return-undefined':
        compiledContent.push('default: return undefined;')
        break
    }

    compiledContent.push('}};')
  }

  const finalName =
    description['output-file'] ||
    fileName.substring(fileName.lastIndexOf('/') + 1, fileName.indexOf('.', fileName.lastIndexOf('/') + 1))
  const finalPath = fileName.substring(0, fileName.lastIndexOf('/')) + '/' + finalName + '.ts'
  await Deno.writeTextFile(finalPath, compiledContent.finalize())
  await Deno.run({ cmd: ['npx', 'prettier', '--write', finalPath], stdout: 'null' }).status()
}
